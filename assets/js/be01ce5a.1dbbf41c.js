"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6199],{9911:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Elements/Block-Model","title":"**Block Models**","description":"block-models}","source":"@site/docs/Elements/Block-Model.md","sourceDirName":"Elements","slug":"/Elements/Block-Model","permalink":"/UserGuideWeb/docs/Elements/Block-Model","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"sidebar_label":"Block Model"},"sidebar":"elementsSidebar","previous":{"title":"Point","permalink":"/UserGuideWeb/docs/Elements/Point"}}');var s=i(4848),o=i(8453);const l={sidebar_label:"Block Model"},r="Block Models {#block-models}",a={},c=[{value:"<strong>Features and considerations</strong>",id:"features-and-considerations",level:2},{value:"<strong>Import</strong>",id:"import-3",level:2},{value:"<strong>Tips for Successful Import</strong>",id:"tips-for-successful-import",level:3},{value:"<strong>Export</strong>",id:"export-2",level:2},{value:"<strong>Manage</strong>",id:"manage-2",level:2},{value:"<strong>Properties</strong>",id:"properties-2",level:2},{value:"<strong>Edit</strong>",id:"edit-1",level:2},{value:"<strong>Create</strong>",id:"create",level:2},{value:"<strong>Step-by-Step Workflow</strong>",id:"step-by-step-workflow",level:3},{value:"<strong>Rotate</strong>",id:"rotate",level:2},{value:"<strong>Populate</strong>",id:"populate",level:2},{value:"<strong>Populate Workflow</strong>",id:"populate-workflow",level:3},{value:"<strong>Calculate</strong>",id:"calculate",level:2},{value:"<strong>Numerical Expressions</strong>",id:"numerical-expressions-1",level:3},{value:"<strong>Conditional Expressions</strong>",id:"conditional-expressions-1",level:3},{value:"<strong>Evaluate</strong>",id:"evaluate",level:2},{value:"<strong>Evaluate workflow</strong>",id:"evaluate-workflow",level:3},{value:"<strong>Downscale</strong>",id:"downscale",level:2},{value:"<strong>Downscale Workflow</strong>",id:"downscale-workflow",level:3},{value:"<strong>Filters</strong>",id:"filters-1",level:2}];function d(e){const n={admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"block-models",children:(0,s.jsx)(n.strong,{children:"Block Models"})})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Block Models"})," section enables you to create and manage block models by importing your database. These models allow you to organize and visualize mining project data, with the added capability to view them in 3D. If you have existing projects in the ",(0,s.jsx)(n.strong,{children:"DrillHole"})," or ",(0,s.jsx)(n.strong,{children:"Point"})," sections, the CSV files you\u2019ve generated and exported can be imported here to construct a block model from that data."]}),"\n",(0,s.jsx)(n.p,{children:"This section offers a wide range of functionalities, from directly building block models based on your project information (specifying properties like block count, spacing, and origin) to performing advanced operations such as calculations, filters, flagging, geostatistical analysis, estimation, and simulations. Whether you're working on basic tasks or complex analyses, this section is designed to support your workflow comprehensively."}),"\n",(0,s.jsxs)(n.p,{children:["Given the integration of block models with the ",(0,s.jsx)(n.strong,{children:"Analysis"})," section, maintaining good organization within your projects is essential. Each block model you create is tied to its respective project, ensuring that calculations, filters, and operations remain independent and well-structured. The interface allows you to manage multiple block models simultaneously, providing flexibility for diverse project requirements."]}),"\n",(0,s.jsx)(n.h2,{id:"features-and-considerations",children:(0,s.jsx)(n.strong,{children:"Features and considerations"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The workflow is designed to be ",(0,s.jsx)(n.strong,{children:"direct"}),", ",(0,s.jsx)(n.strong,{children:"quick"}),", ",(0,s.jsx)(n.strong,{children:"fluid"}),", ",(0,s.jsx)(n.strong,{children:"semi-intuitive"}),", and ",(0,s.jsx)(n.strong,{children:"highly effective"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"All decisions regarding criteria, properties, and characteristics of your block models are saved, ensuring continuity and traceability."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Block Limit"}),": Block models are currently limited to current licence",(0,s.jsx)(n.strong,{children:"s"}),". If this limit is exceeded, the system will notify you with an error message.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": For projects that require models beyond this capacity, please contact support or the development team for alternative solutions."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By leveraging this section, you can effectively construct, manage, and analyze block models tailored to your mining projects. Proper planning and organization are key to maximizing the potential of the tools provided"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"import-3",children:(0,s.jsx)(n.strong,{children:"Import"})}),"\n",(0,s.jsx)(n.p,{children:"To generate a block model, the first step involves importing data from a CSV or ZIP file. Using ZIP files is recommended for faster upload speeds. Below is a step-by-step guide to the import process:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Import Process"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Upload the Block Model File"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Select and upload the block model file in CSV or ZIP format."}),"\n",(0,s.jsx)(n.li,{children:"Ensure the data is clean and properly structured, format, for accurate processing."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Choose the Block Model Type"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Decide whether the model to be imported is:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Regular"}),": Composed of blocks with uniform sizes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Irregular (Sub-Cell)"}),": Includes blocks with varying sizes for detailed modeling."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Selecting the correct structure is crucial to ensure accurate representation of the model."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Specify the Header and Data Rows"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Indicate the row where the header is located (e.g., row 1)."}),"\n",(0,s.jsx)(n.li,{children:"Specify the starting row for the data (e.g., row 2)."}),"\n",(0,s.jsx)(n.li,{children:"This ensures the system correctly identifies column names and data entries."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Select Variables to Import"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Assign the relevant columns in the dataset to corresponding data types, such as:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easting, Northing, and Elevation coordinates"})," (mandatory)."]}),"\n",(0,s.jsxs)(n.li,{children:["Block dimensions: ",(0,s.jsx)(n.strong,{children:"xsize, ysize, zsize"})," (if applicable)."]}),"\n",(0,s.jsx)(n.li,{children:"Additional variables (numerical or categorical)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Handle missing values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Assign a placeholder value (e.g., -99 for numerical data or "unknown" for categorical data).'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Use the ",(0,s.jsx)(n.strong,{children:"Data Table View"})," tab to preview the dataset, helping ensure columns and rows are mapped correctly."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rotation Check"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Before finalizing, decide whether to:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rotate the Block Model"}),': Specify the rotation point (Easting and Northing) and the azimuth angle. Original coordinates will be preserved under the columns "Orig_X" and "Orig_Y".']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Proceed without Rotation"}),": Import the model as is, aligned to its current coordinates."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"tips-for-successful-import",children:(0,s.jsx)(n.strong,{children:"Tips for Successful Import"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always clean the dataset before importing to ensure all required fields are present and formatted correctly."}),"\n",(0,s.jsxs)(n.li,{children:["Missing data placeholders (e.g., ",(0,s.jsx)(n.code,{children:"-99"}),' for numerical or "unknown" for categorical) should be configured as needed.']}),"\n",(0,s.jsxs)(n.li,{children:["Verify column assignments using the ",(0,s.jsx)(n.strong,{children:"Data Table View"})," tab for a clear visualization of the dataset structure."]}),"\n",(0,s.jsx)(n.li,{children:"Use ZIP format whenever possible for faster uploads, especially for large block models."}),"\n"]})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"By following these steps, you can ensure an efficient and accurate block model import process, enabling you to proceed with constructing and analyzing your data seamlessly."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"export-2",children:(0,s.jsx)(n.strong,{children:"Export"})}),"\n",(0,s.jsx)(n.p,{children:"In this section, you can select both categorical and numerical variables that you wish to export, as well as those you do not wish to export."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Select the Block Model:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"From the 'BlockModel' dropdown menu, select the block model project from which you wish to export data."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Apply Filters:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If you have created filters within the selected project, you can apply them by choosing the appropriate filter from the 'Filter' dropdown menu. Remember, if multiple filters are available, they cannot be applied simultaneously\u2014you'll need to create a combined filter if necessary."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Select Attributes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check the boxes next to 'Categorical Attributes' and 'Numerical Attributes' to select the variables you wish to export. By default, the East, North, and Elevation coordinates are included."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Export File:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Once you have made your selections, click the 'Export' button. The file will be saved in CSV format to your computer, which can then be used as needed for your analyses or presentations."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"manage-2",children:(0,s.jsx)(n.strong,{children:"Manage"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Block Model Manager"})," is designed for managing block model datasets used in geological and mining workflows. It supports renaming, exporting, and deleting block models, ensuring streamlined management of volumetric data."]}),"\n",(0,s.jsx)(n.p,{children:"Key Features"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Viewing and Organizing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Displays a list of all imported block models with attributes like ",(0,s.jsx)(n.strong,{children:"name"}),", ",(0,s.jsx)(n.strong,{children:"creation date"}),", and ",(0,s.jsx)(n.strong,{children:"size"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Users can sort and group block models for efficient navigation and organization."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Renaming"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enables users to assign meaningful names to block models, making it easier to distinguish between datasets."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exporting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Generates ",(0,s.jsx)(n.strong,{children:"CSV files"})," of block model data, using the same name as the block model dataset."]}),"\n",(0,s.jsxs)(n.li,{children:["Exported files typically include columns for:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Block ID"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Coordinates (X, Y, Z)"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Attributes"})," (e.g., grade, density, lithology)"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deleting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Removes block model datasets permanently from the workspace."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Caution"}),": Ensure no critical data is lost before deletion."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example: CSV Download"}),"\n",(0,s.jsx)(n.p,{children:"A block model named MB_Demo would export as MB_Demo.csv, including data like:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Block ID"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"X"}),", ",(0,s.jsx)(n.strong,{children:"Y"}),", ",(0,s.jsx)(n.strong,{children:"Z"})," (block centroid coordinates as Easting, Northing, Elevation)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Grade values"})," (e.g., Au, Ag)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other attributes"})," (e.g., density, rock type)"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," In the ",(0,s.jsx)(n.strong,{children:"Properties and Edit"})," section, you can view, modify, and manage various attributes or columns of the dataset. Additionally, you can create new attributes using calculated fields and customize the content for export through a tailored download."]})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"properties-2",children:(0,s.jsx)(n.strong,{children:"Properties"})}),"\n",(0,s.jsx)(n.p,{children:"In this section, you can select the block model project, which will indicate its general attributes such as name, number of blocks per coordinate, the model's origin point, and block size."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Follow these steps:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Select the Block Model Project:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use the 'BlockModel' dropdown to select the block model project you wish to examine."}),"\n",(0,s.jsx)(n.li,{children:"Once a project is selected, the interface will display general attributes such as the project's name, the number of blocks per coordinate, the model's origin point, and block size."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["View Model Attributes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The selected block model's details are then presented. You will see the total number of blocks, as well as the numeric and categorical variables that have been loaded into the model."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Examine the Database:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"At the bottom part of the interface, the database is visually presented in a tabulated form showing rows and columns."}),"\n",(0,s.jsx)(n.li,{children:"This view will typically show the first 100 elements, providing a snapshot of the model's dataset."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Secondly, it will display the attributes of the created model details; total number of blocks, numeric variables, and categorical variables loaded into it. At the bottom, the database will be visually displayed with its rows and columns for the first 100 elements."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"edit-1",children:(0,s.jsx)(n.strong,{children:"Edit"})}),"\n",(0,s.jsx)(n.p,{children:"We have the capability to modify the imported data by altering column names, adjusting attribute types between numerical or categorical, and potentially removing columns from the database. Following the desired modifications, it is imperative to execute the 'apply' option to enact these changes. An example of modification and how the interface looks."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Select the Block Model: Choose the block model you want to edit from the 'BlockModel' dropdown menu."}),"\n",(0,s.jsxs)(n.li,{children:["Edit Column Names and Types: For each column in the dataset:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Change the column name by typing the new desired name into the 'New Name' field corresponding to that column."}),"\n",(0,s.jsx)(n.li,{children:"Adjust the attribute type by selecting either 'Numerical' or 'Categorical' from the dropdown menu in the 'Data Type' column."}),"\n",(0,s.jsx)(n.li,{children:"If you wish to remove a column entirely, select 'Delete' from the 'Data Type' dropdown menu for that column."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Apply Changes: Once all desired modifications are made, click the 'Apply' button to save the changes to the database."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example of Modification:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"To rename the column 'Mo_Nuestro' to 'Mo_I', you would enter 'Mo_I' in the 'New Name' field for the 'Mo_Nuestro' row."}),"\n",(0,s.jsx)(n.li,{children:"To remove the 'Mo_Ellos' column from the database, you would select 'Delete' from the 'Data Type' dropdown for the 'Mo_Ellos' row."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note: The columns 'Easting', 'Northing', and 'Elevation' are essential to the data structure and are not available for modification in this interface."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"create",children:(0,s.jsx)(n.strong,{children:"Create"})}),"\n",(0,s.jsx)(n.p,{children:"This section allows for the creation of a block model by defining the number of blocks per coordinate, the origin point, and the block size in that orientation."}),"\n",(0,s.jsx)(n.h3,{id:"step-by-step-workflow",children:(0,s.jsx)(n.strong,{children:"Step-by-Step Workflow"})}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Define Block Model Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Navigate to the section for creating a new block model within the software."}),"\n",(0,s.jsx)(n.li,{children:"Enter the number of blocks per coordinate axis (Easting, Northing, and Elevation)."}),"\n",(0,s.jsx)(n.li,{children:"Specify the origin point coordinates where the block model should begin."}),"\n",(0,s.jsx)(n.li,{children:"Set the size for each block within the model, ensuring that it corresponds to the actual physical measurements you intend to represent."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 2: Initialize the Block Model"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Upon defining the parameters, initiate the creation of the block model."}),"\n",(0,s.jsx)(n.li,{children:"The software will generate a preliminary volume represented by empty-white blocks. These blocks constitute the basic structure of your model without any assigned attributes or data."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 3: Manipulate and Add Data to Blocks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use filters to select and manipulate specific blocks within the model."}),"\n",(0,s.jsx)(n.li,{children:"Apply calculations and other options to assign data and attributes to the blocks."}),"\n",(0,s.jsx)(n.li,{children:"If needed, import or input data to enrich the model with information relevant to your project."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 4: Visualize and Verify the Model"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Utilize the software\u2019s visualization tools to view the block model in 3D."}),"\n",(0,s.jsx)(n.li,{children:"Verify that the block dimensions and placement correspond to your project requirements."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 5: Apply the Creation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"After reviewing all parameters and data, confirm the creation of the block model."}),"\n",(0,s.jsx)(n.li,{children:"Select the 'Create New Block Model' option to finalize and construct the model within the software."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 6: Save and Continue Workflow"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Once the block model is created, save the project."}),"\n",(0,s.jsx)(n.li,{children:"A confirmation message should appear, signaling successful creation. If there are issues, such as exceeding the maximum number of blocks (e.g., 20 million), an error message will guide you to make necessary adjustments."}),"\n",(0,s.jsx)(n.li,{children:"The new block model will now be available for selection and use in other workflows, marking it as a new active project."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"rotate",children:(0,s.jsx)(n.strong,{children:"Rotate"})}),"\n",(0,s.jsx)(n.p,{children:"In a manner akin to the rotation feature available for point-type elements within the workspace section, users have the option to select a project (database) for applying rotation. This process necessitates specification of parameters for the Easting, Northing coordinates, and an angle measured from 0 to 360 degrees as azimuth with respect to the North."}),"\n",(0,s.jsx)(n.p,{children:"Upon applying the rotation, the original coordinates are preserved within newly created columns named Orig_X and Orig_Y, while the columns designated for Easting and Northing are updated with the new coordinates."}),"\n",(0,s.jsx)(n.p,{children:"This functionality ensures internal workflow consistency within the software by seamlessly incorporating these adjustments into the dataset."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"populate",children:(0,s.jsx)(n.strong,{children:"Populate"})}),"\n",(0,s.jsx)(n.p,{children:"Here, you'll discover how to complete incomplete block models and generate relevant extensions effectively."}),"\n",(0,s.jsx)(n.h3,{id:"populate-workflow",children:(0,s.jsx)(n.strong,{children:"Populate Workflow"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Complete Missing Data:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Fill in missing data or blocks to ensure your model aligns with the "snap-to-grid" principle for precise accuracy.'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Generate Model Extensions:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"To experiment with different scenarios or to integrate new data, generate extensions within your block model."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Define Model Parameters:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'In the "Final Extension" interface, crucial parameters such as origin and block size are determined. Specify the necessary details to accurately define your Block Model.'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Review and Verify:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"After setting your parameters, review all aspects and verify your project's details to ensure everything is correct."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Populate Your Model:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Click on the "Populate Block Model" button to apply changes and update your project. A visual representation of before and after the population process can help to confirm the success of the operation.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"calculate",children:(0,s.jsx)(n.strong,{children:"Calculate"})}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will walk you through the process of using numerical and conditional expressions to compute new data columns, focusing on generating new attributes in your dataset from operations and calculations performed on and between existing columns. The first step is to select the project, the database, with which you will be working, or in other words, the block model."}),"\n",(0,s.jsx)(n.h3,{id:"numerical-expressions-1",children:(0,s.jsx)(n.strong,{children:"Numerical Expressions"})}),"\n",(0,s.jsx)(n.p,{children:"To calculate new numerical values based on existing data, we use numerical expressions. These expressions allow you to perform arithmetic operations directly in Pandas."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["How to Use: Simply type your numerical expression into the 'Condition' field when adding a new attribute. Use standard arithmetic operators like ",(0,s.jsx)(n.strong,{children:"+"})," (addition), ",(0,s.jsx)(n.strong,{children:"-"})," (subtraction), ",(0,s.jsx)(n.strong,{children:"*"})," (multiplication), ",(0,s.jsx)(n.strong,{children:"/"})," (division), and ",(0,s.jsx)(n.strong,{children:"**"})," (exponentiation). You can also include Numpy functions and constants in these expressions for more complex calculations."]}),"\n",(0,s.jsx)(n.li,{children:"Important Note: Always include the dataframe reference df when using column names in your expressions."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example 1: To scale a column named 'cus' by 100 and then divide by the column 'cut' increased by 0.0001, you would enter 100*df['cus']/(df['cut'] + 0.0001)."}),"\n",(0,s.jsx)(n.p,{children:"Example 2: For a calculation involving Numpy's constant pi and a column named 'length', the expression would be 4/3*np.pi*df['length']**3."}),"\n",(0,s.jsx)(n.h3,{id:"conditional-expressions-1",children:(0,s.jsx)(n.strong,{children:"Conditional Expressions"})}),"\n",(0,s.jsx)(n.p,{children:"Conditional expressions are used to create new columns based on conditions. These are written using apply() and lambda functions in Pandas."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"How to Use: Type the condition directly into the 'Condition' field. This will implicitly create a lambda function that applies your condition to each row in the dataframe."}),"\n",(0,s.jsx)(n.li,{children:"Important Note: Use row to reference individual row values in your conditional expressions."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example 1: To assign a value based on the contents of the 'Ue' column, enter: \"IN\" if row['Ue'] in (0,1) else \"MIDDLE\" if row['Ue'] == 8 else \"OUT\"."}),"\n",(0,s.jsx)(n.p,{children:"Example 2: To categorize rows based on the 'Litho' and 'FrnE' columns, the condition would be: \"IN\" if row['Litho'] in ('FrLm','FrNE') else \"MIDDLE\" if row['Litho'] == \"OX\" else \"OUT\"."}),"\n",(0,s.jsx)(n.p,{children:"Applying Your Expressions: Once you've entered your custom attribute name, chosen the data type, and typed in your condition, simply click on the 'Add new attribute' button. This will add the new computed column to your dataframe based on the expressions you've provided."}),"\n",(0,s.jsx)(n.p,{children:"Final Tips"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always ensure your expressions are syntactically correct to avoid errors."}),"\n",(0,s.jsx)(n.li,{children:"Refer to the official Pandas documentation for more detailed information on functions and syntax."}),"\n",(0,s.jsx)(n.li,{children:"Experiment with simple expressions first before moving on to more complex computations."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By following this guide, you should be able to enhance your data analysis by adding new, dynamically computed attributes to your Pandas dataframe with ease."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"These notes are also referenced in the Calculate section for 'Points.' This is because both the Points and Blocks sections of the workflow feature a designated area for performing calculations. In both cases, the mathematical construction follows the same guidelines and parameters.*"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"evaluate",children:(0,s.jsx)(n.strong,{children:"Evaluate"})}),"\n",(0,s.jsx)(n.p,{children:"The Evaluate tool allows users to classify and label blocks in a block model based on their position relative to uploaded Topographies and/or Meshes. This tool is essential for creating stratigraphic, lithological, or categorical profiles by sequentially applying evaluation surfaces to the block model."}),"\n",(0,s.jsx)(n.h3,{id:"evaluate-workflow",children:(0,s.jsx)(n.strong,{children:"Evaluate workflow"})}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Select the Block Model"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"From the dropdown menu, select the block model you want to evaluate."}),"\n",(0,s.jsx)(n.li,{children:"Ensure the block model is already uploaded and available in the project."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 2: Add New Attribute"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use the option to add a new attribute. The options for topographies or meshes to use are displayed."}),"\n",(0,s.jsx)(n.li,{children:"You must name the attribute and indicate the order. Follow the next steps"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 3: Define Evaluation Surfaces"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Choose the Topographies and/or Meshes from the available project data to apply as evaluation surfaces."}),"\n",(0,s.jsxs)(n.li,{children:["The evaluation surfaces will classify blocks based on their relative position:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Topography: Blocks above the topography are labeled as Air."}),"\n",(0,s.jsx)(n.li,{children:"Meshes: Blocks within a mesh will be labeled with the corresponding mesh name."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 4: Organize the Evaluation Order"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The order of the surfaces is critical and must follow a logical sequence to ensure proper categorization.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For example: Air \u2192 Lithology 1 \u2192 Lithology 2, progressing from higher elevations to lower elevations."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"This sequential approach allows the creation of consistent stratigraphic or lithological profiles."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 5: Apply the Evaluation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Click on Apply to assign a custom attribute to the block model based on the evaluation criteria."}),"\n",(0,s.jsx)(n.li,{children:"Unclassified blocks (those not assigned by any surface) will automatically be labeled as Unknown."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 6: Review and Finalize"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"After applying the evaluation, the labeled attribute will be added to the block model database."}),"\n",(0,s.jsx)(n.li,{children:"If needed, remove an Evaluate Attribute setting without affecting the attribute column in the block model."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Key Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Topographies"}),": Only classify blocks above them (e.g., Air)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meshes"}),": Classify blocks within their boundaries, using the mesh name as the label."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Order Consistency"}),": Maintain a consistent sequence for evaluation surfaces to achieve meaningful categorizations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unclassified Blocks"}),": Blocks that do not match any surface criteria will be labeled as ",(0,s.jsx)(n.strong,{children:"Unknown"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Iterative Process"}),": Think of this as constructing profiles step by step, ensuring precision in every layer."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"downscale",children:(0,s.jsx)(n.strong,{children:"Downscale"})}),"\n",(0,s.jsx)(n.p,{children:"The Downscale tool allows users to refine an existing block model by creating a new model with a higher resolution. This process subdivides the blocks into smaller units, enabling more detailed analysis and modeling. The tool supports both regular and sub-cell block models. Below is the step-by-step workflow:"}),"\n",(0,s.jsx)(n.h3,{id:"downscale-workflow",children:(0,s.jsx)(n.strong,{children:"Downscale Workflow"})}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Select the Block Model"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"From the dropdown menu, choose the block model you wish to refine through downscaling."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 2: Review the Current Block Model Definition"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A summary table will display the descriptive parameters of the selected block model, including:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Direction (Easting, Northing, Elevation)"}),"\n",(0,s.jsx)(n.li,{children:"# Blocks: Number of blocks along each direction."}),"\n",(0,s.jsx)(n.li,{children:"Origin: Starting point of the block model."}),"\n",(0,s.jsx)(n.li,{children:"Max Block Size: Maximum size of the blocks in each direction."}),"\n",(0,s.jsx)(n.li,{children:"Min Block Size: Minimum size of the blocks in each direction."}),"\n",(0,s.jsx)(n.li,{children:"Current Number of Blocks: Total number of blocks in the existing model."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 3: Adjust Subdivision Settings"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use the interactive sliders to specify the scaling factor for each axis:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Easting"}),"\n",(0,s.jsx)(n.li,{children:"Northing"}),"\n",(0,s.jsx)(n.li,{children:"Elevation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["The scaling factor can be set to 1, 2, or 3, where:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1: No change (blocks retain their original size)."}),"\n",(0,s.jsx)(n.li,{children:"2: Subdivide each block in the axis into two smaller blocks."}),"\n",(0,s.jsx)(n.li,{children:"3: Subdivide each block in the axis into three smaller blocks."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 4: Preview the New Block Model Definition"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["As you adjust the sliders, a preview table on the right will update in real-time, showing the new parameters for the block model:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Updated # Blocks, Origin, Max Block Size, and Min Block Size for each direction."}),"\n",(0,s.jsx)(n.li,{children:"New Number of Blocks: The total number of blocks in the new model."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 5: Define the New Block Model Name"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enter a unique name for the new block model in the input field provided."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Step 6: Apply Downscaling"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Click the Apply Downscaling button to generate the new block model with the refined resolution."}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Downscale"})," tool works for both ",(0,s.jsx)(n.strong,{children:"regular"})," and ",(0,s.jsx)(n.strong,{children:"sub-cell"})," block models."]}),(0,s.jsx)(n.p,{children:"The original block model remains unchanged, and the downscaled model is saved as a separate entity with the new name you provide."})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"filters-1",children:(0,s.jsx)(n.strong,{children:"Filters"})}),"\n",(0,s.jsx)(n.p,{children:"When using filters, we implicitly utilize the Query function from the Pandas library. You write a condition as a string. You can use logical operators such as and, or, and not, as well as comparison operators like >, <, >=, <=, ==, and !=. You can reference column names directly without having to use['column_name'] syntax within the query string. The use of parentheses can be helpful when we want to specify different operations grouped within the string. Another important aspect is when to use quotes. We will explain two case:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Column Identifiers: In the context of querying a data structure, when you reference the names of columns, you usually don\u2019t need to use quotes if these names follow the conventions of the language or environment you're working with. For example, if column names cannot contain spaces or special characters and must not clash with reserved keywords, then a plain, unquoted identifier is sufficient."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"String Literals: Conversely, when your query needs to match specific text within a column, that text should be enclosed in quotes. This tells the system you\u2019re looking for an exact sequence of characters, not a column or another type of identifier. So, 'Unit 1' in quotes signifies it\u2019s a literal string to be matched in the data, not a reference to another column or entity."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We will explain the examples presented on the platform."}),"\n",(0,s.jsx)(n.p,{children:"For example 1: The condition is (Numerical_Attribute > 30) and ((Categorical_Attribute == 'Unit 1') or (Categorical_Attribute == 'Unit 2')). This means that you want to select rows where the 'Numerical_Attribute' column has a value greater than 30, and at the same time, the 'Categorical_Attribute' column must be either 'Unit 1' or 'Unit 2'."}),"\n",(0,s.jsxs)(n.p,{children:["For example 2: The condition is 'Unit_3', 'Unit_7' not in Categorical_Attribute.",(0,s.jsx)(n.br,{}),"\n","This means you want to exclude rows where the 'Categorical_Attribute' is either 'Unit_3' or 'Unit_7'."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Note: These notes are also mentioned in the Filters section for 'Points.' This is because both the Points and Blocks sections of the workflow have a dedicated area for applying filters. In both instances, the filter construction adheres to the same guidelines and parameters."})})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);